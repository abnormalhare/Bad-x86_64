#include "x86/x86.c"

#include "evntprov.h"

__declspec(noreturn) void __cdecl _amsg_exit(int errnum);

void ASM_pre_c_init(void) {
    ASM_4X(0x48); ASM_83(0xEC, 0x00, 0x00, 0x28);
    ASM_BH(0xB8, 0x5A4D); // checks if characters are MZ!
    ASM_66(); ASM_39(0x05, 0x00, 0xFFFFED50);
    ASM_74(0x04, 12B6);

JMP_12B2:
    ASM_33(0xC0, 0x00, 0x00);
    ASM_EB(0x53, 1309);

JMP_12B6:
    ASM_4X(0x48); ASM_63(0x0D, 0x00, 0xFFFFED7F);
    ASM_4X(0x48); ASM_8D(0x05, 0x00, 0xFFFFED3C);
    ASM_4X(0x48); ASM_03(0xC8, 0x00, 0x00);
    ASM_81(0x39, 0x00, 0x00, 0x4550);
    ASM_75(0xE3, 12B2);
    ASM_BH(0xB8, 0x10B);
    ASM_66(); ASM_39(0x41, 0x00, 0x18);
    ASM_74(0x1E, 12F8);
    ASM_BH(0xB8, 0x20B);
    ASM_66(); ASM_39(0x41, 0x00, 0x18);
    ASM_75(0xCD, 12B2);
    ASM_33(0xC0, 0x00, 0x00);
    ASM_83(0xB9, 0x00, 0x00000084, 0x0E);
    ASM_76(0x19, 1309);
    ASM_39(0x81, 0x00, 0x000000F8);
    ASM_EB(0x0E, 1306);

JMP_12F8:
    ASM_33(0xC0, 0x00, 0x00);
    ASM_83(0x79, 0x00, 0x74, 0x0E);
    ASM_76(0x09, 1309);
    ASM_39(0x81, 0x00, 0x000000E8);

JMP_1306:
    { Data data = {0, .rm_code = 0xC0 };
      ASM_0F(0x95, &data);
    }

JMP_1309:
    ASM_BH(0xB9, 0x2);
    ASM_89(0x05, 0x00, 0x17DCC);
    ASM_E8(0x48F);
    // ...

    printf("!!! ----- !!!\n");

    //TODO complete this
    ASM_33(0xC0, 0x00, 0x00);
    ASM_4X(0x48); ASM_83(0xC4, 0x00, 0x00, 0x28);
    ASM_C3();
}

void ASM___wmainCRTStartup(void) {
    ASM_4X(0x48); ASM_8B(0xC4, 0x00, 0x00);
    ASM_4X(0x48); ASM_89(0x58, 0x00, 0x08);
    ASM_4X(0x48); ASM_89(0x70, 0x00, 0x10);
    ASM_4X(0x48); ASM_89(0x78, 0x00, 0x18);
    ASM_4X(0x4C); ASM_89(0x70, 0x00, 0x20);
    ASM_4X(0x41); ASM_5L(0x57);
    ASM_4X(0x48); ASM_81(0xEC, 0x00, 0x00, 0x000000B0);
    ASM_4X(0x45); ASM_33(0xF6, 0x00, 0x00);
    ASM_4X(0x44); ASM_89(0x74, 0x24, 0x20);
    ASM_4X(0x48); ASM_8D(0x48, 0x00, 0x88);
    ASM_FF(0x15, 0x00, 0xDF6A);
    ASM_90();

JMP_13FF:
    ASM_65(); ASM_4X(0x48); ASM_8B(0x04, 0x25, 0x30);
    ASM_4X(0x48); ASM_8B(0x58, 0x00, 0x08);
    ASM_4X(0x41); ASM_8B(0xF6, 0x00, 0x00);

JMP_140F:
    ASM_33(0xC0, 0x00, 0x00);
    { Data data = { .rm_code = 0x1D, .disp = 0x182C6 };
      ASM_F0(); ASM_4X(0x48); ASM_0F(0xB1, &data);
    }
    ASM_74(0x1B, 1437);
    ASM_4X(0x48); ASM_3B(0xC3, 0x00, 0x00);
    ASM_75(0x09, 142A);
    ASM_BH(0xBF, 0x1);
    ASM_8B(0xF7, 0x00, 0x00);
    ASM_EB(0x12, 143C);

JMP_142A:
    ASM_BH(0x89, 0x3E8);
    ASM_FF(0x15, 0x00, 0xDFAB);
    ASM_EB(0xD8, 140F);

JMP_1437:
    ASM_BH(0xBF, 0x1);

JMP_143C:
    ASM_8B(0x05, 0x00, 0x182A6);
    ASM_3B(0xC7, 0x00, 0x00);
    ASM_75(0x0E, 1454);
    ASM_BH(0xBB, 0x1F);
    ASM_8B(0xCB, 0x00, 0x00);
    ASM_E8(0x3A2); // exit
    ASM_EB(0x76, 14CA);

JMP_1454:
    ASM_8B(0x05, 0x00, 0x1828E);
    ASM_85(0xC0, 0x00, 0x00);
    ASM_75(0x61, 14BF);
    ASM_89(0x3D, 0x00, 0x18284);
    ASM_4X(0x4C); ASM_8D(0x3D, 0x00, 0xE335);
    ASM_4X(0x48); ASM_8D(0x1D, 0x00, 0xE316);
    ASM_4X(0x48); ASM_89(0x5C, 0x24, 0x30);
    ASM_4X(0x41); ASM_8B(0xC6, 0x00, 0x00);
    ASM_89(0x44, 0x24, 0x24);

JMP_147E:
    ASM_4X(0x49); ASM_3B(0xDF, 0x00, 0x00);
    ASM_73(0x2E, 14B1);
    ASM_85(0xC0, 0x00, 0x00);
    ASM_75(0x2E, 14B5);
    ASM_4X(0x4C); ASM_39(0x33, 0x00, 0x00);
    ASM_74(0x1A, 14A6);
    ASM_4X(0x49); ASM_BH(0xBA, 0xD30527475E523070);
    ASM_4X(0x48); ASM_8B(0x03, 0x00, 0x00);
    ASM_4X(0x48); ASM_8B(0x0D, 0x00, 0xE2B8);
    ASM_FF(0xD1, 0x00, 0x00);
    ASM_89(0x44, 0x24, 0x24);

JMP_14A6:
    ASM_4X(0x48); ASM_83(0xC3, 0x00, 0x00, 0x08);
    ASM_4X(0x48); ASM_89(0x5C, 0x24, 0x30);
    ASM_EB(0xCD, 147E);

JMP_14B1:

JMP_14B5:

JMP_14BF:

JMP_14CA:
    // 0x1648
    ASM_C3();
}

void ASM_wWinMainCRTStartup(void) {
    ASM_4X(0x48); ASM_83(0xEC, 0x00, 0x00, 0x28);
    ASM_E8(0x28B);
    ASM_4X(0x48); ASM_83(0xC4, 0x00, 0x00, 0x28);
    ASM_E9(0xFFFFFD5E);
}

void ASM_RtlpImageNtHeader(void) {
    ASM_4X(0x48); ASM_83(0xEC, 0x00, 0x00, 0x18);
    ASM_33(0xD2, 0x00, 0x00);
    ASM_4X(0x48); ASM_8D(0x41, 0x00, 0xFF);
    ASM_4X(0x48); ASM_83(0xF8, 0x00, 0x00, 0xFD);
    ASM_77(0x3C, 1798);

JMP_175C:
    ASM_BH(0xB8, 0x5A4D);
    ASM_66(); ASM_39(0x01, 0x00, 0x00);
    ASM_75(0x2A, 1790);
    ASM_39(0x51, 0x00, 0x31);
    ASM_7C(0x25, 1790);
    ASM_81(0x79, 0x00, 0x3C, 0x1000003C);
    ASM_73(0x1C, 1790);
    ASM_4X(0x48); ASM_63(0x41, 0x00, 0x3C);
    ASM_4X(0x48); ASM_03(0xC1, 0x00, 0x00);
    ASM_4X(0x48); ASM_89(0x04, 0x24, 0x00);
    ASM_81(0x38, 0x00, 0x00, 0x4550);
    

JMP_1790:

JMP_1798:
    ASM_4X(0x48); ASM_8B(0xC2, 0x00, 0x00);
    ASM_4X(0x48); ASM_83(0xC4, 0x00, 0x00, 0x18);
    ASM_C3();
}

void ASM__get_image_app_type(void) {
    ASM_4X(0x40); ASM_5L(0x53);
    ASM_4X(0x48); ASM_83(0xEC, 0x00, 0x00, 0x20);
    ASM_8B(0xD9, 0x00, 0x00);
    ASM_33(0xC9, 0x00, 0x00);
    ASM_FF(0x15, 0x00, 0xDB50);
    ASM_4X(0x48); ASM_85(0xC0, 0x00, 0x00);
    ASM_74(0x29, 17E6);
    ASM_4X(0x48); ASM_8B(0xC8, 0x00, 0x00);
    ASM_E8(0xFFFFFF87);

JMP_17E6:
}

void ASM__amsg_exit_0(void) {
    ASM_FF(0x25, 0x00, 0xDDF6);
}

void ASM___security_init_cookie(void) {
    ASM_4X(0x48); ASM_89(0x5C, 0x24, 0x20);
    ASM_5L(0x55);
    ASM_4X(0x48); ASM_8B(0xEC, 0x00, 0x00);
    ASM_4X(0x48); ASM_83(0xEC, 0x00, 0x00, 0x20);
    ASM_4X(0x48); ASM_83(0x65, 0x00, 0x18, 0x00);
    ASM_4X(0x48); ASM_BH(0xBB, 0x2B992DDFA232);
    ASM_4X(0x48); ASM_8B(0x05, 0x00, 0x17781);
    ASM_4X(0x48); ASM_3B(0xC3, 0x00, 0x00);
    { Data data = { .val = 0x93 }; ASM_0F_I(85, &data, 19B3); }
    ASM_4X(0x48); ASM_8D(0x4D, 0x00, 0x18);
    ASM_FF(0x15, 0x00, 0xDACE);
    ASM_4X(0x48); ASM_8B(0x45, 0x00, 0x18);
    ASM_4X(0x48); ASM_89(0x45, 0x00, 0x10);
    ASM_FF(0x15, 0x00, 0xDA50);
    ASM_8B(0xC0, 0x00, 0x00);
    ASM_4X(0x48); ASM_31(0x45, 0x00, 0x10);
    ASM_FF(0x15, 0x00, 0xDA2C);
    ASM_8B(0xC0, 0x00, 0x00);
    ASM_4X(0x48); ASM_31(0x45, 0x00, 0x10);
    ASM_FF(0x15, 0x00, 0xDAA0);
    ASM_8B(0xC0, 0x00, 0x00);
    ASM_4X(0x48); ASM_C1(0xE0, 0x00, 0x00, 0x18);
    ASM_4X(0x48); ASM_31(0x45, 0x00, 0x10);
    ASM_FF(0x15, 0x00, 0xDA90);
    ASM_8B(0xC0, 0x00, 0x00);
    ASM_4X(0x48); ASM_8D(0x4D, 0x00, 0x10);
    ASM_4X(0x48); ASM_33(0x45, 0x00, 0x10);
    ASM_4X(0x48); ASM_33(0xC1, 0x00, 0x00);
    ASM_4X(0x48); ASM_8D(0x4D, 0x00, 0x20);
    ASM_4X(0x48); ASM_89(0x45, 0x00, 0x10);
    ASM_FF(0x15, 0x00, 0xDA25);
    ASM_8B(0x45, 0x00, 0x20);
    ASM_4X(0x48); ASM_BH(0xB9, 0xFFFFFFFFFFFF);
    ASM_4X(0x48); ASM_C1(0xE0, 0x00, 0x00, 0x20);
    ASM_4X(0x48); ASM_33(0x45, 0x00, 0x20);
    ASM_4X(0x48); ASM_33(0x45, 0x00, 0x10);
    ASM_4X(0x48); ASM_23(0xC1, 0x00, 0x00);
    ASM_4X(0x48); ASM_8B(0xC8, 0x00, 0x00);
    ASM_4X(0x48); ASM_3B(0xC3, 0x00, 0x00);
    ASM_75(0x0D, 19AC);
    ASM_4X(0x48); ASM_BH(0xB8, 0x2B992DDFA233);
    ASM_4X(0x48); ASM_8B(0xC8, 0x00, 0x00);

JMP_19AC:
    ASM_4X(0x48); ASM_89(0x0D, 0x00, 0x176E5);

JMP_19B3:
    ASM_4X(0x48); ASM_8B(0x5C, 0x24, 0x48);
    ASM_4X(0x48); ASM_F7(0xD0, 0x00, 0x00, 0x00);
    ASM_4X(0x48); ASM_89(0x05, 0x00, 0x176DE);
    ASM_4X(0x48); ASM_83(0xC4, 0x00, 0x00, 0x20);
    ASM_5H(0x5D);
    ASM_C3();
}

void ASM__guard_dispatch_icall_nop(void) {
    ASM_FF(0xE0, 0x00, 0x00);
}

void ASM__guard_xfg_dispatch_icall_nop(void) {
    ASM_FF(0x25, 0x00, 0xEE2);
}

// extern //
void ASM_GetModuleHandleW(void) {
    LPCWSTR arg0 = (LPCWSTR)regs[1].r;
    HMODULE ret = GetModuleHandleW(arg0);
    regs[0].r = (u64)ret;
    ASM_C3();
}

void ASM_GetStartupInfoW(void) {
    LPSTARTUPINFOW arg0 = (LPSTARTUPINFOW)&stack[regs[1].e];
    GetStartupInfoW(arg0);
    ASM_C3();
}


void ASM_GetCurrentThreadId(void) {
    regs[0].e = GetCurrentThreadId();
    ASM_C3();
}

void ASM_GetCurrentProcessId(void) {
    regs[0].e = GetCurrentProcessId();
    ASM_C3();
}

void ASM_QueryPerformanceCounter(void) {
    LARGE_INTEGER *arg0 = (LARGE_INTEGER*)&stack[regs[1].e];
    regs[0].e = QueryPerformanceCounter(arg0);
    ASM_C3();
}

void ASM_Sleep(void) {
    DWORD arg0 = regs[1].e;
    Sleep(arg0);
    ASM_C3();
}

void ASM_GetTickCount(void) {
    regs[0].e = GetTickCount();
    ASM_C3();
}

void ASM_GetSystemTimeAsFileTime(void) {
    LPFILETIME arg0 = (LPFILETIME)&stack[regs[1].e];
    GetSystemTimeAsFileTime(arg0);
    ASM_C3();
}

void ASM__amsg_exit(void) {
    int arg0 = regs[1].e;
    _amsg_exit(arg0);
}

void BFSVC_setupStack(void) {
    // HEADER //
    { STACK8 (temp, 0x00000); *temp = 'M'; }
    { STACK8 (temp, 0x00001); *temp = 'Z'; }
    { STACK16(temp, 0x00002); *temp = 0x0090; }
    { STACK16(temp, 0x00004); *temp = 0x0003; }
    { STACK16(temp, 0x00006); *temp = 0x0000; }
    { STACK16(temp, 0x00008); *temp = 0x0004; }
    { STACK16(temp, 0x0000A); *temp = 0x0000; }
    { STACK16(temp, 0x0000C); *temp = 0xFFFF; }
    { STACK16(temp, 0x0000E); *temp = 0x0000; }
    { STACK16(temp, 0x00010); *temp = 0x00B8; }
    { STACK16(temp, 0x00012); *temp = 0x0000; }
    { STACK16(temp, 0x00014); *temp = 0x0000; }
    { STACK16(temp, 0x00016); *temp = 0x0000; }
    { STACK16(temp, 0x00018); *temp = 0x0040; }
    { STACK16(temp, 0x0001A); *temp = 0x0000; }
    { STACK64(temp, 0x0001C); *temp = 0; }
    { STACK16(temp, 0x00024); *temp = 0x0000; }
    { STACK16(temp, 0x00026); *temp = 0x0000; }
    { STACK64(temp, 0x00028); *temp = 0; }
    { STACK64(temp, 0x00030); *temp = 0; }
    { STACK32(temp, 0x00038); *temp = 0; }
    { STACK32(temp, 0x0003C); *temp = 0x000000F8; }
    // ...
    // FUNCTIONS //
    { STACK64(temp, 0x012A0); *temp = (u64)ASM_pre_c_init; }
    { STACK64(temp, 0x013D0); *temp = (u64)ASM___wmainCRTStartup; }
    { STACK64(temp, 0x01660); *temp = (u64)ASM_wWinMainCRTStartup; }
    { STACK64(temp, 0x0174C); *temp = (u64)ASM_RtlpImageNtHeader; }
    { STACK64(temp, 0x017A8); *temp = (u64)ASM__get_image_app_type; }
    { STACK64(temp, 0x017F4); *temp = (u64)ASM__amsg_exit_0; }
    { STACK64(temp, 0x018F4); *temp = (u64)ASM___security_init_cookie; }
    { STACK64(temp, 0x0E840); *temp = (u64)ASM__guard_dispatch_icall_nop; }
    { STACK64(temp, 0x0E860); *temp = (u64)ASM__guard_xfg_dispatch_icall_nop; }
    
    // EXTERN FUNCS //
    { STACK64(temp, 0x0F308); *temp = (u64)&ASM_GetModuleHandleW; }
    { STACK64(temp, 0x0F368); *temp = (u64)&ASM_GetStartupInfoW; }
    { STACK64(temp, 0x0F370); *temp = (u64)&ASM_GetCurrentThreadId; }
    { STACK64(temp, 0x0F388); *temp = (u64)&ASM_GetCurrentProcessId; }
    { STACK64(temp, 0x0F3A0); *temp = (u64)&ASM_QueryPerformanceCounter; }
    { STACK64(temp, 0x0F3E0); *temp = (u64)&ASM_Sleep; }
    { STACK64(temp, 0x0F3F0); *temp = (u64)&ASM_GetTickCount; }
    { STACK64(temp, 0x0F3F8); *temp = (u64)&ASM_GetSystemTimeAsFileTime; }
    { STACK64(temp, 0x0F5F0); *temp = (u64)&ASM__amsg_exit; }

    // __guard_dispatch_icall_fptr
    { STACK64(temp, 0x0F748); *temp = 0xE840; }
    // __guard_xfg_dispatch_icall_ptr
    { STACK64(temp, 0x0F758); *temp = 0xE860; }
    // __xi_a
    { STACK64(temp, 0x0F788); *temp = 0; }
    { STACK64(temp, 0x0F790); *temp = 0x12A0; }
    { STACK64(temp, 0x0F798); *temp = 0x1720; }
    // __xi_z
    { STACK64(temp, 0x0F7A0); *temp = 0; }
    // __security_cookie
    { STACK64(temp, 0x19098); *temp = 0x2B992DDFA232; }
    // __native_startup_lock
    { STACK64(temp, 0x196E0); *temp = 0; }
    // __native_startup_state
    { STACK32(temp, 0x196E8); *temp = 0; }
}

int main() {
    // init
    ASM_init();
    BFSVC_setupStack();

    // start
    ASM_incIP(0x1660, NULL);
    regs[4].r -= 0x8;

    ASM_codeFunc func = ASM_getFunc(regs[16].e);
    func();

    // end
    ASM_exit();
    return 0;
}